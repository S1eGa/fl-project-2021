# fl-project-2021 #

1. [Boost-spirit](#Boost-Spirit)
2. [Parsec](#Parsec)
3. [Pyparse](#Pyparse)

## Boost-Spirit

Используются зависимости:

* boost/spirit
* boost/fusion
* boost/variant

Компиляция проекта происходит при помощи ввода следующей команды:

``` bash
   g++ main.cpp -o src 
```

При запуске программа ожидает путь до файла, написанному на языке
из [description.txt](/description.txt). На выход выдается построенное
AST в случае, если программа принадлежит данному языку
или сообщение об ошибке в обратном случае.

Из особенностей

* Свой лексер и интеграция с ним (так и не воспользовался)
* Интеграция с библиотекой boost::fusion, позволяющая делать различные
  функциональные штуки
* Очень удобная перегрузка операторов для правил

## Тестирование ##

Первые 11 тестов должны показывать, что парсер распознает
языковые особенности, последние два - стрессы. На тесты большего
порядка просто не хватает стека, но и с такими время выполнения
уже достаточно большое. В частности,

```bash
Test #13
real    0m2,653s
user    0m2,442s
sys     0m0,052s
```

```bash
Test #14
real    0m0,618s
user    0m0,601s
sys     0m0,016s
```

Разница в размере входных данных примерно в два раза, но время
отличается так из-за количества откатов. Так как парсер
внутри Boost::Spirit использует алгоритм нисходящего рекурсивного
спуска, то в худшем случае может потребоваться экспоненциальное время.
Так же серьезным фактором, влияющем на время, является объем выходных
данных. Для теста `#13`  он составляет 42 мегабайта, что уже может
в значительной мере повлиять на время выполнения.

При ошибке парсер возвращает фрагмент входного файла, начиная 
с первой не распознанной функции.

## Parsec, Haskell ##

1. Библиотекa монадических парсер комбинаторов `parsec`, библиотека с хорошей документацией,
   большим количеством примеров.
2. Библиотека достаточно удобная, например есть встроенный парсер `buildExpressionParser`, 
   который сильно облегчает парсинг языка, синтаксис очень интуитивный.
3. Обработка ошибок. Встроенная обработка ошибок в `parsec` уже имеет хорошую форму. Сообщение выглядит так:
   строка, символ, какой символ ожидался на самом деле. Пользователю эта информация может быть достаточно полезна, для того чтобы понять, как исправить код. С возможностью кастомизировать сообщения об ошибках я не разбирался.
4. Сложности и минусы `parsec`. Внутри `parsec` работает как LL(1) парсер, что конечно неплохо, но слабее, чем   парсеры из бизона или других парсер-генераторов. Из-за этого, например, в случае `statement = expression`
   `expression` не может начинаться с маленькой латинской буквы, так как там возникает неоднозначность - либо ожидается `assignment` либо `expression`. В таком случае нужно обернуть `expression` в скобки, чтобы все разбиралось однозначно. Помимо этого в остальных местах где были неоднозначности надо было аккуратно задать грамматику. 
5. Время работы на тесте 4 -- 0.9s (724836 байт), на тесте 5 -- 5.8s (2524836 байт), на тесте 6 -- 0.18s (70037 байт). Большие тесты состоят в основном только из выражений, так как вся сложность парсинга приходится именно на выажения, так как все `statement` имеют достаточно простую структуру. Для того чтобы запустить тесты достаточно запустить функцию `checkFile path/to/test`.
